const RitaScriptVisitor = require('./lib/RitaScriptVisitor').RitaScriptVisitor;

/**
 * This Visitor walks the tree generated by parsers and produces Python code
 *
 * @returns {object}
 */
class Visitor extends RitaScriptVisitor {

  constructor(context) {
    super();
    this.context = context || {};
  }

  // Entry point for tree visiting
  start(ctx) {
    return this.visitScript(ctx);
  }

  // Visits children of current node
  visitChildren(ctx) {
    let code = '';
    for (let i = 0; i < ctx.getChildCount(); i++) {
      code += this.visit(ctx.getChild(i));
    }
    return code.trim();
  }

  // Visits a leaf node and returns a string
  visitTerminal(ctx) {
    let txt = ctx.getText();
    return  txt !== '<EOF>' ? txt: ''; // ignore EOFs
  }

  visitScript(ctx) {
    //console.log('visitScript -> "' + ctx.getText() + '"');
    return this.visitChildren(ctx);
  }

  visitEmptyExpr(ctx) {
    return this.visit(ctx.expr());
  }

  visitFullExpr(ctx) {
    //console.log('visitExpr -> "' + ctx.getText() + '"');
    return this.visitChildren(ctx);
  }

  visitSymbol(ctx) {
    //console.log('visitSymbol -> "' + ctx.getText() + '" -> '+this.context[ctx.getText()]);
    let text = ctx.getText();
    return this.context[text] || text;
  }

  visitFullChoice(ctx) {
    let children = this._nonterminalChildren(ctx);
    let picked = this._randomElement(children);
    return this.visit(picked);
  }

  visitEmptyChoice(ctx) {
    let children = this._nonterminalChildren(ctx);
    children.push("");
    let picked = this._randomElement(children);
    return typeof picked === 'string' ? picked : this.visit(picked);
  }

  _nonterminalChildren(ctx) { // TODO: use filter
    let children = [];
    for (let i = 0; i < ctx.getChildCount(); i++) {
      let child = ctx.getChild(i);
      if (child.children) children.push(child);
    }
    return children;
  }

  _randomElement(arr) {
    return arr[Math.floor((Math.random() * arr.length))];
  }
}

module.exports = Visitor;
