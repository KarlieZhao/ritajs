const antlr4 = require('antlr4');
const Operator = require('./operator');
const { RiScriptVisitor } = require('../grammar/.antlr/RiScriptVisitor');
const { RiScriptParser } = require('../grammar/.antlr/RiScriptParser');
const EmptyExpr = new RiScriptParser.ExprContext();

/*
 * This visitor walks the tree generated by a parser, 
 * evaluating each node as it goes.
 */
class Visitor extends RiScriptVisitor {

  constructor(parent) {
    super();
    this.sequence = null;
    this.parent = parent;
  }

  init(context, opts) {
    this.pendingSymbols = [];
    this.context = context || {};
    this.trace = opts && opts.trace;
    return this;
  }

  // Entry point for tree visiting
  start(ctx) {
    return this.visitScript(ctx).trim();
  }

  visitAssign(ctx) {
    // visit value and create a mapping in the symbol table */
    let token = ctx.expr();
    let id = symbolName(ctx.symbol().getText());
    this.trace && console.log('visitAssign: '
      + id + '=' + this.flatten(token) + ']');
    this.context[id] = this.visit(token);
    return ''; // no output on vanilla assign
  }

  visitChars(ctx) {
    this.trace && console.log('visitChars("' + ctx.getText()
      + '"): tfs=' + (ctx.transforms || "[]"));
    let text = ctx.getText().toString();
    return this.handleTransforms(text, ctx.transforms);
  }

  visitChoice(ctx) {

    // compute all options and weights
    let options = [];
    ctx.wexpr().map((w, k) => {
      let wctx = w.weight();
      let weight = wctx ? parseInt(wctx.INT()) : 1;
      let expr = w.expr() || emptyExpr();
      for (let i = 0; i < weight; i++) {
        options.push(expr);
      }
    });

    // handle sequences if we have any
    let token, txs = ctx.transform();
    if (txs.length && txs.filter(t => t.getText().includes('.seq()')).length) {
      token = this.handleSequence(options, false);
    }
    else if (txs.length && txs.filter(t => t.getText().includes('.rseq()')).length) {
      token = this.handleSequence(options, true);
    }

    // then pick a random one if we need
    token = token || randomElement(options) || emptyExpr();
    //let token = randomElement(options) || emptyExpr();

    // merge transforms on entire choice and selected option
    token.transforms = this.inheritTransforms(token, ctx);
    this.trace && console.log('visitChoice: ' + this.flatten(token),
      "tfs=" + (token.transforms || "[]"), this.flatten(options));

    // and then visit
    return this.visit(token);
  }

  visitCexpr(ctx) {
    let conds = ctx.cond();
    this.trace && console.log('visitCexpr(' + ctx.expr().getText() + ')',
      'cond={' + conds.map(c => c.getText().replace(',', '')) + '}');
    for (let i = 0; i < conds.length; i++) {
      let id = symbolName(conds[i].SYM().getText());
      let op = Operator.fromString(conds[i].op().getText());
      let val = conds[i].chars().getText();
      let sym = this.context[id];
      let accept = sym ? op.invoke(sym, val) : false;
      /* this.trace && console.log('  cond(' + ctx.getText() + ')',
        id, op.toString(), val, '->', accept); */
      if (!accept) return this.visitExpr(emptyExpr());
    }
    return this.visitExpr(ctx.expr());
  }

  handleSequence(options, shuffle) {
    if (!this.sequence) {
      this.sequence = new Sequence(options, shuffle);
    }
    return this.sequence.next();
  }
  /*   visitExpr(ctx) {
      this.trace && console.log('visitExpr(\'' + ctx.getText()
        + '\'): tfs=' + (ctx.transforms || "[]"));
      let result = this.visitChildren(ctx);
      return result;
    } */

  /* output expr value and create a mapping in the symbol table */
  visitInline(ctx) {
    let token = ctx.expr();
    let orig = ctx.getText();
    let tokText = token.getText();
    let id = symbolName(ctx.symbol().getText());
    token.transforms = this.inheritTransforms(token, ctx);

    this.trace && console.log('visitInline[pre]: ' + id + '=' +
      this.flatten(token) + ' tfs=[' + (token.transforms || '') + ']');

    this.context[id] = this.visit(token);
    this.trace && console.log('visitInline[pos]: $' + id + '=' + this.context[id]);

    // if the inline is not fully resolved, save it for next time
    if (this.parent.isParseable(this.context[id])) {
      this.pendingSymbols.push(id);
      return orig.replace(tokText, this.context[id]);
    }
    return this.context[id];
  }

  /* visit the resolved symbol */
  visitSymbol(ctx) {

    let ident = ctx.SYM();

    // hack: for blank .func() cases
    if (!ident) return this.handleTransforms('', ctx.transform());

    ident = symbolName(ident.getText());
    // the symbol is pending so just return it
    if (this.pendingSymbols.includes(ident)) return '$' + ident;

    let text = this.context[ident] || '$' + ident;

    // hack to pass transforms along to visitTerminal
    let textContext = { text, getText: () => text };
    textContext.transforms = ctx.transforms || [];
    ctx.transform().map(t => textContext.transforms.push(t.getText()));

    if (0 && typeof text !== 'string') {
      // Here we have a nested object (or RiTa call)
      console.log("***** NOPE", typeof text, text === RiTa, textContext.transforms);
    }

    this.trace && console.log('visitSymbol($' + ident + ')'
      + ' tfs=[' + (textContext.transforms || '') + '] ctx[\''
      + ident + '\']=' + (ident === 'RiTa' ? '{RiTa}' : textContext.text));

    return this.visitTerminal(textContext);
  }

  visitTerminal(ctx) {

    let term = ctx, tfs = ctx.transforms;
    if (typeof ctx.getText === 'function') {
      term = ctx.getText();
    }

    if (typeof term === 'string') {

      if (term === Visitor.EOF) return '';
      term = this.parent.normalize(term);
      this.trace && /\S/.test(term) && console.log
        ('visitTerminal("' + term + '") tfs=[' + (tfs || '') + ']');

      // Re-append transforms on unresolved symbols/groups for next pass
      if (this.parent.isParseable(term)) {
        return term + (tfs ? tfs.reduce((acc, val) => acc +
          (typeof val === 'string' ? val : val.getText()), '') : '');
      }
    }
    else if (typeof term === 'object') {

      // Here we've resolved a symbol to an object in visitSymbol
      this.trace && console.log('visitTerminal2(' + (typeof term) + '): "'
        + JSON.stringify(term) + '" tfs=[' + (tfs || '') + ']');
    }
    else if (typeof term === 'function') {

      // Only happens when calling a RiTa function?
      this.trace && console.log('visitFunction(""): tfs=[' + (tfs || '') + ']');
    }
    else {
      throw Error('Unexpected terminal type=' + (typeof term)); // never
    }

    return this.handleTransforms(term, tfs);
  }

  visitChildren(ctx) {

    if (!ctx.children) return '';

    this.trace && console.log('visitChildren(' + ctx.constructor.name + '): "'
      + ctx.getText() + '"', ctx.transforms || '[]', '[' + ctx.children.reduce(
        (acc, c) => acc += c.constructor.name + ',', '').replace(/,$/, ']'));

    // if we have only one child, transforms apply to it
    if (ctx.children.length === 1) {
      let tok = ctx.children[0];
      tok.transforms = this.inheritTransforms(tok, ctx);
      //console.log('ONECHILDPOLICY', tok.transforms);
      return this.visit(tok);
    }

    // visit each child, pass transforms, and merge their output
    let result = ctx.children.reduce((acc, child) => acc + this.visit(child), '');
    return this.handleTransforms(result, ctx.transforms);
  }

  // ---------------------- Helpers ---------------------------

  /* run the transforms and return the results */
  handleTransforms(obj, transforms) {
    let term = obj;
    if (transforms && transforms.length) {
      let tfs = this.trace ? '' : null; // debug
      for (let i = 0; i < transforms.length; i++) {
        let txf = transforms[i];
        txf = (typeof txf === 'string') ? txf : txf.getText();
        this.trace && (tfs += txf); // debug
        let comps = txf.split('.');
        for (let j = 1; j < comps.length; j++) {
          let comp = comps[j];
          if (comp.length) {
            if (comp.endsWith(Visitor.FUNCTION)) {
              // strip parens
              comp = comp.substring(0, comp.length - 2);
              // handle transforms in context
              if (typeof this.context[comp] === 'function') {
                term = this.context[comp](term);
              }
              // handle built-in string functions
              else if (typeof term[comp] === 'function') {
                term = term[comp]();
              }
              else {
                let msg = 'Expecting ' + term + '.' + comp + '() to be a function';
                if (!this.silent && !RiTa.SILENT) console.warn('[WARN] ' + msg);
                //throw Error(msg);
                term = term + '.' + comp;  // no-op
              }
              // handle object properties
            } else if (term.hasOwnProperty(comp)) {
              if (typeof term[comp] === 'function') {
                throw Error('Functions with args not yet supported: $object.' + comp + '(...)');
              }
              term = term[comp];
              // no-op
            } else {
              term = term + '.' + comp; // no-op
            }
          }
        }
      }
      this.trace && console.log('handleTransforms: ' +
        (obj.length ? obj : "''") + tfs + ' -> ' + term);
    }
    return term;
  }

  getRuleName(ctx) {
    return ctx.hasOwnProperty('symbol') ?
      this.parent.lexer.symbolicNames[ctx.symbol.type] :
      this.parent.parser.ruleNames[ctx.ruleIndex];
  }

  countChildRules(ctx, ruleName) {
    let count = 0;
    for (let i = 0; i < ctx.getChildCount(); i++) {
      if (this.getRuleName(ctx.getChild(i)) === ruleName) count++;
    }
    return count;
  }

  printChildren(ctx) {
    for (let i = 0; i < ctx.getChildCount(); i++) {
      let child = ctx.getChild(i);
      console.log('  child' + i + ':', child.getText(), 'type=' + this.getRuleName(child));
    }
  }

  flatten(toks) {
    if (!Array.isArray(toks)) toks = [toks];
    return toks.reduce((acc, t) => acc += '[' + this.getRuleName(t) + ':' + t.getText() + ']', '');
  }

  flattenChoice(toks) {
    if (!Array.isArray(toks)) toks = [toks];
    return toks.reduce((acc, t) => acc += '[' + this.getRuleName(t) + ':' + t.getText() + ']', 'choice: ');
  }

  inheritTransforms(token, ctx) {
    let ctxTransforms = ctx.transform ? ctx.transform().map(t => t.getText()) : [];
    ctxTransforms = mergeArrays(ctxTransforms, ctx.transforms);
    if (typeof token.transforms === 'undefined') return ctxTransforms;
    return mergeArrays(token.transforms, ctxTransforms);
  }

  handleEmptyChoices(ctx, options) {
    let ors = this.countChildRules(ctx, Visitor.OR);
    let exprs = this.countChildRules(ctx, "expr");
    let adds = (ors + 1) - exprs;
    for (let i = 0; i < adds; i++) {
      options.push(emptyExpr());
    }
  }
}

class NoRepeat {
  //TODO:
}

class Sequence {
  constructor(opts, shuffle) {
    this.last = null;
    this.index = 0;
    this.options = opts;
    this.shuffle = shuffle;
    if (shuffle) this.shuffleOpts();
    /*console.log('new Sequence(' + this.options.map
      (o => o.getText()) + ", " + !!shuffle + ")");*/
  }
  next() {
    //console.log('Sequence#' + this.index);
    while (this.shuffle && this.index === this.options.length) {
      this.shuffleOpts();
      // no repeats
      if (this.options.length < 2 || this.options[0] !== this.last) {
        this.index = 0;
      }
    }
    this.last = this.options[this.index++ % this.options.length];
    return this.last;
  }
  shuffleOpts() {
    let newArray = this.options.slice(), len = newArray.length, i = len;
    while (i--) {
      let p = parseInt(Math.random() * len), t = newArray[i];
      newArray[i] = newArray[p];
      newArray[p] = t;
    }
    this.options = newArray;
  }
}

function randomElement(arr) {
  return arr[Math.floor((Math.random() * arr.length))];
}

function symbolName(text) {
  return (text.length && text[0] === Visitor.SYM) ? text.substring(1) : text;
}

function mergeArrays(orig, adds) {
  return (adds && adds.length) ? (orig || []).concat(adds) : orig;
}

function inspect(o) {
  let props = [];
  let obj = o;
  do {
    props = props.concat(Object.getOwnPropertyNames(obj));
  } while (obj = Object.getPrototypeOf(obj));
  return props.sort().filter(function (e, i, arr) {
    return (e != arr[i + 1]);// && typeof o[e] === 'function');
  });
}

function typeOf(o) {
  if (typeof o !== 'object') return typeof o;
  return Array.isArray(o) ? 'array' : 'object';
}

function emptyExpr() {
  delete EmptyExpr.transforms;
  return EmptyExpr;
}

Visitor.LP = '(';
Visitor.RP = ')';
Visitor.OR = 'OR';
Visitor.SYM = '$';
Visitor.EOF = '<EOF>';
Visitor.ASSIGN = '[]';
Visitor.FUNCTION = '()';

module.exports = Visitor;
